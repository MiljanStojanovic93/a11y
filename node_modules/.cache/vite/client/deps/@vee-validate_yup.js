import "./chunk-ROME4SDB.js";

// node_modules/.pnpm/@vee-validate+yup@4.11.8_vue@3.3.4/node_modules/@vee-validate/yup/dist/vee-validate-yup.esm.js
var isObject = (obj) => obj !== null && !!obj && typeof obj === "object" && !Array.isArray(obj);
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function getTag(value) {
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  return Object.prototype.toString.call(value);
}
function isPlainObject(value) {
  if (!isObjectLike(value) || getTag(value) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function merge(target, source) {
  Object.keys(source).forEach((key) => {
    if (isPlainObject(source[key])) {
      if (!target[key]) {
        target[key] = {};
      }
      merge(target[key], source[key]);
      return;
    }
    target[key] = source[key];
  });
  return target;
}
function toTypedSchema(yupSchema, opts = { abortEarly: false }) {
  const schema = {
    __type: "VVTypedSchema",
    async parse(values) {
      var _a;
      try {
        const output = await yupSchema.validate(values, Object.assign({}, opts));
        return {
          value: output,
          errors: []
        };
      } catch (err) {
        const error = err;
        if (error.name !== "ValidationError") {
          throw err;
        }
        if (!((_a = error.inner) === null || _a === void 0 ? void 0 : _a.length) && error.errors.length) {
          return { errors: [{ path: error.path, errors: error.errors }] };
        }
        const errors = error.inner.reduce((acc, curr) => {
          const path = curr.path || "";
          if (!acc[path]) {
            acc[path] = { errors: [], path };
          }
          acc[path].errors.push(...curr.errors);
          return acc;
        }, {});
        return { errors: Object.values(errors) };
      }
    },
    cast(values) {
      try {
        return yupSchema.cast(values);
      } catch (_a) {
        const defaults = yupSchema.getDefault();
        if (isObject(defaults) && isObject(values)) {
          return merge(defaults, values);
        }
        return values;
      }
    }
  };
  return schema;
}
export {
  toTypedSchema
};
/*! Bundled license information:

@vee-validate/yup/dist/vee-validate-yup.esm.js:
  (**
    * vee-validate v4.11.8
    * (c) 2023 Abdelrahman Awad
    * @license MIT
    *)
*/
//# sourceMappingURL=@vee-validate_yup.js.map
